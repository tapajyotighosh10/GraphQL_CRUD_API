package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"practice/graph/model"
	"practice/graph/postgres"
	"strconv"

	"github.com/360EntSecGroup-Skylar/excelize"
	//"practice/excel"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input *model.NewUser) (*model.User, error) {
	conn := postgres.Conn()
	var res model.User
	log.Println("kmmmmmmmm88888888888888mmmmmmmmmmmm")
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `INSERT INTO public.newdb
	(firstname, lastname, dob)
	VALUES($1, $2, TO_DATE($3, 'MM-DD-YYYY')
	)RETURNING userId`
	// use returning clause
	log.Println("kmmmmmmmmmmmmmmmmmmmm")

	_, err := db.Exec(sqlstatement, input.FirstName, input.LastName, input.Dob)
	log.Println(err, ",,,,,,,,,,,,,,,,")
	if err != nil {
		res.Error = true
		res.Message = err.Error()
		return &res, nil
	}
	res.Error = false
	res.Message = "data inserted successfully"

	fmt.Println("data inserted successfully")

	return &res, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUser) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
	var res *model.User
	conn := postgres.Conn()
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `UPDATE newdb SET firstname =$1 , lastname = $2, dob=TO_DATE($3, 'MM-DD-YYYY') WHERE userId=$4`
	log.Println(sqlstatement)
	_, err := db.Exec(sqlstatement, input.FirstName, input.LastName, input.Dob, input.UserID)
	if err != nil {
		fmt.Println("sql_err", err)
		res.Error = true
		res.Message = err.Error()
		return res, err
	}
	respUser := model.User{
		Error:   false,
		Message: "data updated successfully",
	}

	fmt.Println("data updated successfully")

	return &respUser, nil
}

// RemoveUser is the resolver for the removeUser field.
func (r *mutationResolver) RemoveUser(ctx context.Context, input model.DeleteUser) (string, error) {
	conn := postgres.Conn()
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `DELETE FROM newdb WHERE userId = $1`
	_, err := db.Exec(sqlstatement, input.UserID)
	if err != nil {
		fmt.Println("sql_err", err)
		return "", err
	}

	return "data deleted successfully", nil
}

// FetchStudent is the resolver for the FetchStudent field.
func (r *mutationResolver) FetchStudent(ctx context.Context) ([]*model.User, error) {
	// panic(fmt.Errorf("not implemented: FetchStudent - FetchStudent"))
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := ` select userid::text,firstname,lastname,dob::text from newdb `
	var user1 []*model.User
	data, err := db.Query(sqlStatement)
	// log.Println("data:", &data)
	// log.Println("datas:", data)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}
	for data.Next() {
		var user model.User
		err = data.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Dob)
		if err != nil {
			fmt.Println("sql_err:", err)
			return nil, err
		}
		user1 = append(user1, &user)
	}
	f := excelize.NewFile()
	f.SetCellValue("Sheet1", "A1", "userId")
	f.SetCellValue("Sheet1", "B1", "FirstName")
	f.SetCellValue("Sheet1", "C1", "LastName")
	f.SetCellValue("Sheet1", "D1", "Dob")

	for i, value := range user1 {
		id := *value.ID
		firstname := *value.FirstName
		lastName := *value.LastName
		dob := *value.Dob
		a := strconv.Itoa(i + 2)
		f.SetCellValue("Sheet1", ("A" + a), id)
		f.SetCellValue("Sheet1", ("B" + a), firstname)
		f.SetCellValue("Sheet1", ("C" + a), lastName)
		f.SetCellValue("Sheet1", ("D" + a), dob)

	}

	err = f.SaveAs("NewData.xlsx")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("Excel File created and data inserted")
	}
	return user1, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// }
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := ` SELECT firstname, lastname, dob FROM newdb WHERE userid=$1 `
	var user model.User
	err = db.QueryRow(sqlStatement, id).Scan(&user.FirstName, &user.LastName, &user.Dob)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}

	return &user, nil
}

// Username is the resolver for the username field.
func (r *queryResolver) Username(ctx context.Context, firstname *string) ([]*model.User, error) {
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := `SELECT firstname, lastname, dob,userid FROM newdb WHERE firstname=$1`

	rows, err := db.Query(sqlStatement, *firstname)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}
	defer rows.Close()

	var users []*model.User

	for rows.Next() {
		var user model.User
		if err := rows.Scan(&user.FirstName, &user.LastName, &user.Dob, &user.ID); err != nil {
			fmt.Println("row_scan_err:", err)
			return nil, err
		}
		users = append(users, &user)
	}

	if err := rows.Err(); err != nil {
		fmt.Println("row_err:", err)
		return nil, err
	}
	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
